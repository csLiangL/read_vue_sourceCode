# 数据劫持

![](./img/数据劫持.awebp)

# 依赖收集(订阅)

- 假设 某**计算属性 b** 是通过 **数据a(data的某个属性)** 转化得到，则我们希望 **数据a 在变化时 能够通知到 a本身 以及 b**。
- Vue1.0中的做法是 **定义watcherA和watcherB**，分别对应a 和 b，他们 **都用来监听属性数据a**，以便于在属性a发生改变的时候，watcherA用来改变 a本身，watcherB则用来改变 b。
- 既然他们都 监听 属性数据a，则不妨给 属性数据a 添加一个Dep，可以将其简单理解为一个数组，里面就存放着 **监听属性a的两个watcher**，这样 属性数据a发生改变后，只要遍历 一遍数组，就能将所有 的依赖 都更新一遍了。
- 而 给属性添加Dep数组 自然就发生在 **defineProperty()** 中，依赖收集即给数组增加元素 则发生在 **属性的 getter** 里面。
- 这里 将watcher 一个个 推入 Dep数组中，就是 **订阅过程**。

>tips:
>
>- 在Vue1.0中：一个watcher只监听一个数据，页面更新也只更新这一个节点，粒度很细。
>
>- 在Vue2.0中，一个watcher监听一个组件，页面更新以组件为单位，粒度扩大了。

> tips：
>
> - 只有当Dep.target存在时，才会进行依赖收集。
> - 即依赖收集前，一定会判断 Dep.target是否存在。

# 派发更新(发布)

- dep 对应 **某一个属性的 一群watcher**。

- 派发更新即 **发布过程** 就是将数组中的watcher一个个拿出来更新，则自然发生 在setter里，因此数据改变必然触发setter。

# 整体流程

## initData数据初始化

- 首先就是数据劫持，递归地调用defineProperty, 把_data中的每个属性 及 属性的属性 变成响应式。

- 代理：**本质上仍是调用defineProperty**, 让app._data中的属性映射到app的属性上。


## mount挂载组件

- 创建render函数：将 真实DOM 转化为 虚拟DOM 缓存起来。

- 创建watcher，执行render函数，将 虚拟DOM + _data 渲染到页面中。

    - **渲染时必定发生 数据属性的读取**， 此时进行 **依赖收集**。

    - 让 该属性的dep 记录下此时的watcher。

    - 让 该watcher 监听 该属性的dep。


## 当数据发生改变时

- 属性的dep 去 notify，通知 该属性所有的watcher 进行更新，即 **派发更新**。

- 而在 更新过程中，即渲染过程，又会发生 **依赖收集**。




